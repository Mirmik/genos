#include <asm/stm32_usb.h>

void stm32_usb_reset(void)
{
    int buf1;

    unsigned short int DISCRIPTOR0[4] = {   64,             // ADDR_TX = 64 оставлено место для всех 8 дискрипторов перед буфером приема(можно оставить меньше)
                                            0,              // COUNT_TX = 0 нужно будет заполнить перед отправкой данных
                                            128,            // ADDR_RX = 128 пропускаем 64 байта буфера передачи
                                            33792
                                        };         // Указываем размер буфера приема 64 байта


    RCC -> APB1ENR |= RCC_APB1ENR_USBEN;    // Без включения тактирования, пакетная память не работает (возвращаются только нули)

    TO_WRITE_PMA(DISCRIPTOR0, 0, 4);        // Заполняем дискриптор нулевой точки

    CNTR = 0;
    BTABLE = 0;                             // Адрес таблицы дискрипторов внутри пакетной памяти
    ISTR = 0;                               // Флаги прерываний(событий) USB

    // Инициализация EP0R. Сложность в том, что разные биты имеют разный тип обращения (RW, toggle, и. др.)
    // Разрешен прием данных, установлен тип точки CONTROL, запрещена передача
    buf1 = EP0R;
    buf1 = buf1 ^ 12288;                    //0011000000000000b ( ^ - это XOR ) (Включить два бита STAT_RX с учетом того, что они имеют тип toggle)
    buf1 = buf1 & 12288;                    //0011000000000000b (Сбросить все биты кроме STAT_RX)
    buf1 = buf1 | 512;                      //0000001000000000b (Один бит нужно просто установить (EP_TYPE) (он просто типа RW)
    EP0R = buf1;

    DADDR = 128;                            // Включаем модуль USB, адрес устройства 0

    ISTR &= ~ISTR_RESET;
}
